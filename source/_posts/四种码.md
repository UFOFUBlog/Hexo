---
title: 四种码
top: false
cover: false
toc: true
mathjax: true
date: 2022-05-21 08:10:31
summary: 被这四种码弄得死去活来的
password:
tags:
  - 学习笔记
categories:
---

## 序言

芜湖，被催更了。

我想想，自从三月份开始断更，现在已经五月份了，那么至少漏了四篇了。

以后我尽量每一个月/两个月写一篇。

最近看《静静的顿河》看到第二本了，这部著作看完后应该也会写一篇读后感。

不过啥时候看完，啥时候出推文，我也拿捏不准。

只能说，尽力而为吧。

好了，那不多说废话了，我们进入主题。

最近被几个码弄得死去活来的，所以本次准备谈谈这几个码，主要讲讲原码，反码，补码，移码。

本篇力争通俗一点，因为这几个玩意真的太容易看睡着了。

## 正文

首先，我们要明确一点——计算机内部用什么方式表示数，其实是无所谓的。只要能够保持一一对应的关系，就可以用任意方式表示数。

比如我可以做一个散列函数，然后制定相应的冲突规则，只要一一对应的关系能够保证，那么我的这种方式也算一种编码，只是效率比较低罢了。

所以，既然可以任意选择，那么理应选择一种最方便的方式。

而最方便的方式可能有多种，抑或是慢慢迭代出来。

所以这四个码，就是那个时代最后产出的精华。

我们先从最容易理解的原码开始。

### 1. 原码

我对原码的理解就是“原始码”，很原始，很直观。

它的规则特别简单。

我们把它比作新冠，

正数就是米国，新冠来了没啥大影响，接着奏乐接着舞；

负数则是动态清零地区，新冠来了需要戴上口罩，也就是在最高位置1，然后依然可以奏乐和起舞，但总归有些不舒服。

>比如x1=+0.1101, x2=-1110，字长8位，
>
>那么他们的原码表示为
>
>[x1]原=0.1101000, [x2]原=10001110
>
>

可见，最高位是符号位。数值位（剩余7位）没变动。

细心的同学可能会注意到数字中的一个特例——0.

0又没正负，原码怎么表示呢？

原码很粗暴——既然0和协议冲突，那就为0开个特权吧，用两个值表示0，一个是+0，一个是-0.

其中，-0为1000 0000，+0为0000 0000

当然了，有两个值表示0不一定是坏事，因为IEEE 754下的浮点数的尾数就是用原码表示的，在大家都用补码的时代下，为什么要用原码呢？

因为：

>1.区分正0和负0。在计算某些复杂初等函数的时候，用原码可以更容易实现数值精确——浮点数本身是近似的，这样不仅可以知道实值接近0而不是-1，还可以记住实值在零的哪一边。
>
>2.补码可以连带符号位加减的好处是有“操作数宽度相同”这一条件的，浮点数尾数需要加减的时候宽度不一定相同
>
>3.正负范围相同。使得对于任意可表示的x，其相反数-x也可表示

现在，原码的设计已经完成，不过因为这些都是为计算机设计的，所以还得看计算机老兄的接受程度如何。

数据在计算机里面除了存储，还有一个功能就是成为计算的原料。

计算分为四大块：加减乘除。

不过归根到底这些都可以用加法表示。

所以我们着重看看原码在加法中的表现，尤其是正数+负数的情况。

此处实例借鉴于阮老师的例子（自己手打太累了doge，侵删）：

>随便写一个计算式，16 + (-8) = ?
>
>16的二进制表示是 00010000，
>
>用原码，加法就要写成：
>
>　０００１００００
>＋１０００１０００
>－－－－－－－－－
>　１００１１０００
>
>可以看到，如果按照正常的加法规则，就会得到10011000的结果，转成十进制就是-24。
>
>显然，这是错误的答案。
>
>也就是说，在这种情况下，正常的加法规则不适用于正数与负数的加法。
>
>因此必须制定两套运算规则，一套用于正数加正数，还有一套用于正数加负数。
>
>从电路上说，就是必须为加法运算做两种电路。

计算机：我超，你这是想累死我？还是说你想成为习武之人呢？（“习武之人”在这的意思是电脑太重，天天背着就当锻炼身体了）

可见，原码在计算两数相减上，是有巨大漏洞的。

对原码懂一点的小伙伴可能会说，原码不是有加减法的吗？

对，原码是有加减法的，但是他们的规则如下：

![](tup1.png)

可以看到，原码的加减法要么麻烦，要么用到了补码，那么还不如全用补码一起记呢。

由此我们发现，原码是容易被人脑直接识别并用于计算的，但是计算机可没这个能耐。

上面那张图的加减法都涉及到了符号的区分，计算机辨别"符号位"显然会让计算机的基础电路设计变得更加复杂。

这时候就要想怎么优化了，其中一个重要矛盾便是——符号位处理。

如果符号位能代入计算不就舒服了？

于是人们想出了将符号位也参与运算的方法。

反码也就登上了历史的舞台。

### 2. 反码

反码相当于对原码打了一个补丁。

它是这么定义的：

>符号位拎出来放一边，不变。
>
>正数不变，负数按位全部取反。
>
>当然，因为0有两个原码，所以反码也有两个

比如1的反码为 [0000 0001]反，-1的为[1111 1110]反。

1 - 1 =[0000 0001]反 + [1111 1110]反 = [1111 1111]反 =-0

我们发现用反码计算减法, 结果的真值部分是正确的。

而唯一的问题其实就出现在"0"这个特殊的数值上。

虽然人们理解上+0和-0是一样的，但是0带符号是没有任何意义的，而且会有[0000 0000]反 和[1111 1111]反 两个编码表示0。

于是为了解决了0的符号以及两个编码的问题，补码就出现了。

### 3. 补码

补码是这么定义的：

>正数符号位不变，负数在反码的基础上再加一。

比如1的补码为[0000 0001]补，-1的补码为[1111 1111]补。

为什么补码要做这么奇怪的操作呢？

我们先看出发点。

补码是在反码的基础上演变过来的，反码的核心就是解决加法，尤其是正数+负数的情况。那么补码首先就需要正确的实现加法。

正数大家都默认为基本情况，所以如何对待负数呢？

要将正数转成对应的负数，其实只要用0减去这个数就可以了。比如，-8其实就是0-8。

已知8的二进制是00001000，-8就可以用下面的式子求出：

>　　００００００００
>　－００００１０００
>　－－－－－－－－－

因为0000 0000（被减数）小于0000 1000（减数），所以不够减。所以需要借位。

向谁借？

向被减数的上一位借。

也就是说，被减数其实是1 0000 0000，算式也就改写成：

>１００００００００
>－００００１０００
>－－－－－－－－－
>　１１１１１０００

而1 0000 0000 = 1111 1111 + 1，所以上面的式子可以拆成两个：

>　　１１１１１１１１
>　－００００１０００
>　－－－－－－－－－
>　　１１１１０１１１
>　＋０００００００１
>　－－－－－－－－－
>　　１１１１１０００

所以负数的取反（除符号位）+1就这么诞生了。

当然了，在《深入理解计算机系统》这本书中，作者给出了另一种算负数的补码的方法——负数符号位=1，从低到高遇到的第一个1不变，后面的全部取反。

比如-3=-0000 0011，[-3]补=1111 1101。

第一个1就是末尾的1，不变，其他的全部取反。

这种方法掌握了计算还是比较快的。

至于说为什么“X-Y或X+(-Y)可以用X加上Y的2的补码完成”，不在本文讨论范围内，虽然也不难，但是跑题了，大家有兴趣可以自己查一下相关资料。

至此，补码就可以开心地带者符号位参与运算了。

计算机长舒一口气，打工人也长舒了一口气。

对了，这时候0被唯一定义了，为0000 0000，原码多出来的那个1000 0000 变成了-128，也就是最小的可表示数。

到这时候，我们发现：天啊，自己造出来了个什么玩意？虽然计算机操作起来速度快的要命，但是人脑看起来迷迷糊糊的。

因为这时候数字的本身被补码隐藏，所以数字的大小对人来说不直观。

此时，如果我们将两个数字的**真值**都加上一个相同的值，然后这个值又恰好可以抹除补码带来的迷糊不就完美了？

所以移码振臂一呼：我的时代到来了。

### 4. 移码

移码的数学定义非常简单：

>[x]移=2^n+x
>
>n就是真值的位数，x是真值。
>
>

一般移码都有符号的（占用1位），所以一般都是对于n+1位的移码来说的。

比如，对于字长为8的来说：

>x1=+10101,移码为2^7+10101，
>
>x2=-10101,移码为2^7+(-10101)

其中，比如那个x2，它的移码是0110 1011，而它的补码是1110 1011，符号位刚好取反。

再找几个测试，我们发现，同一个数的移码和补码，数值相同，符号相反。

移码实际上就是改变了补码的符号位，从0变1，从1变0。

这样一来，当我们知道了一个数的补码后，只需要替换它的符号位，就可以得到移码，从而与其他数值进行直接比较了。

当然了，0的移码也就是：1000 0000。因为补码一个标识0，所以移码也是一个标识0。

因为大家都是加上一个相同的数，所以：

1. 移码全0，表示最小值-2^n，全1：表示最大值2^n-1（都是对于n+1位）

2. 保持原有数据的大小顺序，即移码大，真值大。

从数轴上看，移码就相当于把数字整体右移了，原本的索引只是一起偏移了而已。

所以我们叫它：移码。

## 尾声

原本还想讲一下IEEE 754下的浮点数的，但考虑到这玩意展开可能就刹不住车了，所以只得作罢。

本文主要参考了4份链接：

> 1. https://blog.csdn.net/weixin_43927272/article/details/119963856
> 2. https://www.ruanyifeng.com/blog/2009/08/twos_complement.html
> 3. https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/computercode.html
> 4. https://segmentfault.com/a/1190000024426172

希望大家都有所收获。

## 感谢阅读！
